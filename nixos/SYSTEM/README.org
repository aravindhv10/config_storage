* WORK SPACE

** Only tangle
#+begin_src emacs-lisp :results silent
  (save-buffer)
  (org-babel-tangle)
  (async-shell-command "

          alejandra 'configuration.nix' ;
          alejandra 'hardware-configuration.nix' ;

          git add 'do_copy.sh' ;
          git add 'configuration.nix' ;
          git add 'hardware-configuration.nix' ;
          git add 'README.org' ;
          git add 'rebuild_boot.sh' ;
          git add 'rebuild_switch.sh' ;

          rm -vf -- '#configuration.nix#' ;
          rm -vf -- 'README.org~' ;

      " "log" "err")
#+end_src

** Copy the config file:

*** Call the script
#+begin_src emacs-lisp :results silent
 (async-shell-command "./do_copy.sh" "log" "err")
#+end_src

* Script to rebuild and switch

** with /var/tmp as tmp

*** switch
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./rebuild_switch.sh
  export TMPDIR='/var/tmp'
  nixos-rebuild switch
#+end_src

*** boot
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./rebuild_boot.sh
  export TMPDIR='/var/tmp'
  nixos-rebuild switch
#+end_src

* Script to copy the config files
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./do_copy.sh
  cd "$('dirname' '--' "${0}")"

  C () {
      export SUDO_ASKPASS="${HOME}/SUDO_ASKPASS"
      sudo -A cp -vf -- "./${1}" "/etc/nixos/${1}"
  }
#+end_src

* hardware-configuration

** Script to copy the files to the destination
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./do_copy.sh
  C 'hardware-configuration.nix'
#+end_src

Do not modify this file!  It was generated by ‘nixos-generate-config’
and may be overwritten by future invocations.  Please make changes
to /etc/nixos/configuration.nix instead.

** inputs used
#+begin_src nix :tangle ./hardware-configuration.nix
{ config, lib, pkgs, modulesPath, ... }: 
#+end_src

** Start the main function
#+begin_src nix :tangle ./hardware-configuration.nix
  {
#+end_src

*** Import important stuff
#+begin_src nix :tangle ./hardware-configuration.nix
  imports = [(modulesPath + "/installer/scan/not-detected.nix")];
#+end_src

*** List of fiesystems

**** Main root filesystem
#+begin_src nix :tangle ./hardware-configuration.nix
  fileSystems."/" = {
    device = "/dev/disk/by-partlabel/linux";
    fsType = "btrfs";
    options = [ "subvol=@" "compress=zstd:3" ];
  };
#+end_src

**** EFI boot partition
#+begin_src nix :tangle ./hardware-configuration.nix
  fileSystems."/boot" = {
    device = "/dev/disk/by-partlabel/efi";
    fsType = "vfat";
    options = [ "fmask=0077" "dmask=0077" ];
  };
#+end_src

*** Swap stuff
#+begin_src nix :tangle ./hardware-configuration.nix
  swapDevices = [{device = "/dev/disk/by-partlabel/swap0";}];
#+end_src

** Done with hardware configuration
#+begin_src nix :tangle ./hardware-configuration.nix
  }
#+end_src

* Main config

** Script to copy the files to the destination
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./do_copy.sh
  C 'configuration.nix'
#+end_src

Edit this configuration file to define what should be installed on
your system.  Help is available in the configuration.nix(5) man page
and in the NixOS manual (accessible by running ‘nixos-help’).

** Header
#+begin_src nix :tangle ./configuration.nix
  { config, lib, pkgs, modulesPath, ... }:
#+end_src

** Additional definitions

*** BEGIN
#+begin_src nix :tangle ./configuration.nix
  let
#+end_src

*** DEFINE

**** importing unstable
#+begin_src nix :tangle ./configuration.nix
  unstable = import <nixos-unstable> {} ;
#+end_src

**** COMMENT Import my changes
#+begin_src nix :tangle ./configuration.nix
  custom = import /home/asd/GITHUB/NixOS/nixpkgs {} ;
#+end_src

*** END
#+begin_src nix :tangle ./configuration.nix
  in
#+end_src

** Main part of the config

*** BEGIN
#+begin_src nix :tangle ./configuration.nix
  {
#+end_src

*** DEFINE

**** Import hardware configuration
#+begin_src nix :tangle ./configuration.nix
  imports = [./hardware-configuration.nix];
#+end_src

**** Bootloader.

***** BEGIN
#+begin_src nix :tangle ./configuration.nix
  boot.loader = {
#+end_src


***** MAIN

****** COMMENT systemd boot
#+begin_src nix :tangle ./configuration.nix
  systemd-boot.enable = true;
#+end_src

****** EFI Related
#+begin_src nix :tangle ./configuration.nix
  efi = {
    canTouchEfiVariables = true;
    efiSysMountPoint = "/boot/efi"; # ← use the same mount point here.
  };
#+end_src

****** GRUB Related

******* BEGIN
#+begin_src nix :tangle ./configuration.nix
  grub = {
#+end_src

******* MAIN

******** EFI support
#+begin_src nix :tangle ./configuration.nix
  efiSupport = true;
#+end_src

******** Device
#+begin_src nix :tangle ./configuration.nix
  device = "/dev/nvme0n1";
#+end_src

******** COMMENT efiInstallAsRemovable
in case =canTouchEfiVariables= doesn't work for your system
#+begin_src nix :tangle ./configuration.nix
  efiInstallAsRemovable = true; 
#+end_src

******** Extra entries

********* BEGIN
#+begin_src nix :tangle ./configuration.nix
      extraEntries = ''
#+end_src

********* MAIN

********** Debian
#+begin_src nix :tangle ./configuration.nix
  menuentry "debian" {
      linux /k root=/dev/disk/by-partlabel/linux rootflags=subvolid=904 dolvm zswap.enabled=1 zswap.max_pool_percent=80 zswap.zpool=zsmalloc
      initrd /i
  }
#+end_src

********** Nixos with debian kernel
#+begin_src nix :tangle ./configuration.nix
  menuentry "nixos_debian_kernel" {
      linux /k root=/dev/disk/by-partlabel/linux rootflags=subvol=@ init=/nix/store/jyx1xdiw44nwkmimnbrp76njniaphya3-nixos-system-nixos-24.11.715908.7105ae395770/init dolvm zswap.enabled=1 zswap.max_pool_percent=80 zswap.zpool=zsmalloc
      initrd /i
  }
#+end_src

********* END
#+begin_src nix :tangle ./configuration.nix
  '' ;
#+end_src

******* END
#+begin_src nix :tangle ./configuration.nix
  };
#+end_src

***** END
#+begin_src nix :tangle ./configuration.nix
   };
#+end_src

**** Fonts


***** COMMENT Global options
#+begin_src nix :tangle ./configuration.nix
  fonts.fontconfig.localConf = ''
  ''
#+end_src


***** COMMENT Nerd Fonts
#+begin_src nix :tangle ./configuration.nix
fonts.packages = with pkgs; [ nerdfonts ];
#+end_src

**** Networking

***** BEGIN
#+begin_src nix :tangle ./configuration.nix
  networking = {
#+end_src


***** MAIN

****** COMMENT wpa_supplicant
Enables wireless support via wpa_supplicant.
#+begin_src nix :tangle ./configuration.nix
  wireless.enable = true;
#+end_src

****** COMMENT Proxy
Configure network proxy if necessary
#+begin_src nix :tangle ./configuration.nix
  proxy.default = "http://user:password@proxy:port/";
  proxy.noProxy = "127.0.0.1,localhost,internal.domain";
#+end_src

****** Enable networking with network manager
#+begin_src nix :tangle ./configuration.nix
  networkmanager.enable = true;
#+end_src

****** COMMENT Open ports in the firewall.
#+begin_src nix :tangle ./configuration.nix
  firewall.allowedTCPPorts = [ ... ];
  firewall.allowedUDPPorts = [ ... ];
#+end_src

****** Enable nftables
#+begin_src nix :tangle ./configuration.nix
  nftables.enable = true;
#+end_src

****** COMMENT Or disable the firewall altogether.
#+begin_src nix :tangle ./configuration.nix
  firewall.enable = false;
#+end_src

****** Enables DHCP on each ethernet and wireless interface
In case of scripted networking (the default) this is the recommended approach.
#+begin_src nix :tangle ./configuration.nix
  useDHCP = lib.mkDefault true;
#+end_src

****** COMMENT per-interface declarations
When using systemd-networkd it's
still possible to use this option, but it's recommended to use it in conjunction
with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
#+begin_src nix :tangle ./configuration.nix
  interfaces.wlp1s0.useDHCP = lib.mkDefault true;
#+end_src

***** END
#+begin_src nix :tangle ./configuration.nix
  };
#+end_src

**** Host platform and firmware
#+begin_src nix :tangle ./configuration.nix
  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
#+end_src

**** Initrd and kernel modules
#+begin_src nix :tangle ./configuration.nix
  boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "ahci" "uas" "sd_mod" ];
  boot.initrd.kernelModules = [];
  boot.kernelModules = [ "kvm-amd" "amdgpu" ];
  boot.extraModulePackages = [];
#+end_src

**** Env vars
#+begin_src nix :tangle ./configuration.nix
  environment.variables = {ROC_ENABLE_PRE_VEGA = "1"; EDITOR = "hx";};
#+end_src

**** GPU drivers related
#+begin_src nix :tangle ./configuration.nix
  hardware.opengl.extraPackages = [pkgs.amdvlk pkgs.rocmPackages.clr.icd];
#+end_src

***** Some config for ROCM drivers
#+begin_src nix :tangle ./configuration.nix
    systemd.tmpfiles.rules = [
      "L+    /opt/rocm/hip   -    -    -     -    ${pkgs.rocmPackages.clr}"
    ];
#+end_src

***** For 32 bit applications 
#+begin_src nix :tangle ./configuration.nix
  hardware.graphics.enable32Bit = true;
  hardware.opengl.extraPackages32 = [pkgs.driversi686Linux.amdvlk];
#+end_src

**** Kernel Package

***** COMMENT 6.12
#+begin_src nix :tangle ./configuration.nix
    boot.kernelPackages = pkgs.linuxPackages_6_12; 
#+end_src

***** COMMENT 6.6
#+begin_src nix :tangle ./configuration.nix
    boot.kernelPackages = pkgs.linuxKernel.packages.linux_6_6;
#+end_src

***** COMMENT Xanmod

****** COMMENT Latest
#+begin_src nix :tangle ./configuration.nix
    boot.kernelPackages = pkgs.linuxKernel.packages.linux_xanmod_latest;
#+end_src

****** Stable
#+begin_src nix :tangle ./configuration.nix
    boot.kernelPackages = pkgs.linuxKernel.packages.linux_xanmod_stable;
#+end_src

***** Custom build

****** COMMENT 4
#+begin_src nix :tangle ./configuration.nix
  boot.kernelPackages =
      pkgs.linuxManualConfig {
          version = "6.13.9";
          modDirVersion = "6.13.9";
          src = /home/asd/linux_kernel/linux-6.13.9.tar;
          configfile = /home/asd/linux_kernel/config-6.13.9;
      }
  ;
#+end_src

****** COMMENT 3
#+begin_src nix :tangle ./configuration.nix
  boot.kernelPackages =
      pkgs.linuxPackages_custom {
          version = "6.13.9";
          src = /home/asd/linux_kernel/linux-6.13.9.tar;
          configfile = /home/asd/linux_kernel/config-6.13.9;
      }
  ;
#+end_src

linuxPackages_custom {version = "6.13.9"; src = /home/asd/linux_kernel/linux-6.13.9.tar; configfile = /home/asd/linux_kernel/config-6.13.9;}

****** 2
#+begin_src nix :tangle ./configuration.nix
  boot.kernelPackages =
  let
      linux_sgx_pkg = { fetchurl, buildLinux, ... } @ args:
          buildLinux (
              args // rec {
                  version = "6.12.19-xanmod1" ;
                  modDirVersion = version;
                  src = /home/asd/GITLAB/xanmod/linux-6.12.19.tar;
                  kernelPatches = [];
                  extraConfig = ''
                  '';
                  extraMeta.branch = version ;
              } // (args.argsOverride or {})
          );
      linux_sgx = pkgs.callPackage linux_sgx_pkg{};
  in 
      pkgs.recurseIntoAttrs (pkgs.linuxPackagesFor linux_sgx);
#+end_src

****** COMMENT 1
#+begin_src nix :tangle ./configuration.nix
  boot.kernelPackages =
  let
      linux_sgx_pkg = { fetchurl, buildLinux, ... } @ args:
          buildLinux (
              args // rec {
                  version = "6.13.0";
                  modDirVersion = version;
                  src = /home/asd/GITHUB/torvalds/linux-6.13.tar;
                  kernelPatches = [];
                  extraConfig = ''
                  '';
                  extraMeta.branch = "6.13.0";
              } // (args.argsOverride or {})
          );
      linux_sgx = pkgs.callPackage linux_sgx_pkg{};
  in 
      pkgs.recurseIntoAttrs (pkgs.linuxPackagesFor linux_sgx);
#+end_src

**** Kernel command line
#+begin_src nix :tangle ./configuration.nix
  boot.kernelParams = [ "zswap.enabled=1" "zswap.max_pool_percent=80" ];
#+end_src

**** COMMENT Replace kwin with wayfire
#+begin_src nix :tangle ./configuration.nix
  fileSystems."/run/wrappers/bin/kwin_wayland" = {device = "/run/current-system/sw/bin/wayfire"; fsType = "none"; options = ["bind"];};
#+end_src

**** Mount tmpfs on /tmp

***** Better way
#+begin_src nix :tangle ./configuration.nix
  boot.tmp = {
    useTmpfs = true ;
    tmpfsSize = "60%" ;
  } ;
#+end_src

***** COMMENT Standard way
#+begin_src nix :tangle ./configuration.nix
  fileSystems."/tmp" = {device = "none"; fsType = "tmpfs"; };
#+end_src

**** Hostname
Define your hostname.
#+begin_src nix :tangle ./configuration.nix
  networking.hostName = "nixos";
#+end_src

**** Set your time zone.
#+begin_src nix :tangle ./configuration.nix
  time.timeZone = "Asia/Kolkata";
#+end_src

**** Select internationalisation properties.
#+begin_src nix :tangle ./configuration.nix
  i18n.defaultLocale = "en_IN";

  i18n.extraLocaleSettings = {
    LC_ADDRESS = "en_IN";
    LC_IDENTIFICATION = "en_IN";
    LC_MEASUREMENT = "en_IN";
    LC_MONETARY = "en_IN";
    LC_NAME = "en_IN";
    LC_NUMERIC = "en_IN";
    LC_PAPER = "en_IN";
    LC_TELEPHONE = "en_IN";
    LC_TIME = "en_IN";
  };
#+end_src

**** XServer / Wayland + drivers
Enable the X11 windowing system.
You can disable this if you're only using the Wayland session.
#+begin_src nix :tangle ./configuration.nix
  services.xserver = {
      enable = true;
      videoDrivers = [ "amdgpu" ];
  } ;
#+end_src

**** Display manager

***** SDDM
#+begin_src nix :tangle ./configuration.nix
  services.displayManager.sddm = {
      enable = true;
      wayland.enable = true;
      settings.General.DisplayServer = "wayland";
  } ;
#+end_src

***** COMMENT GDM
#+begin_src nix :tangle ./configuration.nix
  services.xserver.displayManager.gdm.enable = true;
#+end_src

**** Desktop environment

***** Wayfire
#+begin_src nix :tangle ./configuration.nix
  programs.wayfire = {
      enable = true;
      package = unstable.wayfire;
      plugins = [
          pkgs.wayfirePlugins.firedecor
          pkgs.wayfirePlugins.focus-request
          pkgs.wayfirePlugins.wayfire-plugins-extra
          pkgs.wayfirePlugins.wayfire-shadows
          pkgs.wayfirePlugins.wcm
          pkgs.wayfirePlugins.wf-shell
          pkgs.wayfirePlugins.windecor
          pkgs.wayfirePlugins.wwp-switcher
      ];
  } ;
#+end_src

****** add Wayfire to the display manager entries
#+begin_src nix :tangle ./configuration.nix
  services.displayManager.sessionPackages = [ unstable.wayfire ];
#+end_src

***** Enable the KDE Plasma Desktop Environment.
#+begin_src nix :tangle ./configuration.nix
  services.desktopManager.plasma6.enable = true;
#+end_src

***** Hyprland
#+begin_src nix :tangle ./configuration.nix
  programs.hyprland = {
      enable = true;
      package = unstable.hyprland;
      withUWSM = true; # recommended for most users
      # withUWSM = false; # recommended for most users
      xwayland.enable = true; # Xwayland can be disabled.
  };
#+end_src

***** Enable the Gnome Desktop Environment.
#+begin_src nix :tangle ./configuration.nix
  services.xserver.desktopManager.gnome.enable = true;
#+end_src

****** Exclude packages in gnome
#+begin_src nix :tangle ./configuration.nix
  environment.gnome.excludePackages = (with pkgs; [
    atomix # puzzle game
    cheese # webcam tool
    epiphany # web browser
    evince # document viewer
    geary # email reader
    gedit # text editor
    gnome-characters
    gnome-music
    gnome-photos
    gnome-terminal
    gnome-tour
    hitori # sudoku game
    iagno # go game
    tali # poker game
    totem # video player
    seahorse
  ]);
#+end_src

**** Editors

***** COMMENT Helix
#+begin_src nix :tangle ./configuration.nix
  programs.helix = {
    enable = true;
    package = unstable.helix;
    settings = {
      theme = "modus_vivendi";
      editor.cursor-shape = {
        normal = "block";
        insert = "bar";
        select = "underline";
      };
    };
    languages.language = [{
      name = "nix";
      auto-format = true;
      formatter.command = lib.getExe pkgs.alejandra;
    }];
  };
#+end_src

**** Configure keymap in X11
#+begin_src nix :tangle ./configuration.nix
  services.xserver.xkb = {
    layout = "us";
    variant = "";
  };
#+end_src

**** Enable CUPS to print documents.
#+begin_src nix :tangle ./configuration.nix
  services.printing.enable = true;
#+end_src

**** Enable Man pages
#+begin_src nix :tangle ./configuration.nix
  documentation = {
      enable = true;
      man.enable = true;
      dev.enable = true;
  } ;
#+end_src

**** Enable sound with pipewire.
#+begin_src nix :tangle ./configuration.nix
  # hardware.pulseaudio.enable = false;
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
    # If you want to use JACK applications, uncomment this
    #jack.enable = true;

    # use the example session manager (no others are packaged yet so this is enabled by default,
    # no need to redefine it in your config for now)
    #media-session.enable = true;
  };

  # services.pipewire.extraConfig.pipewire."91-null-sinks" = {
    # "context.objects" = [
      # {
        # # A default dummy driver. This handles nodes marked with the "node.always-driver"
        # # properyty when no other driver is currently active. JACK clients need this.
        # factory = "spa-node-factory";
        # args = {
          # "factory.name" = "support.node.driver";
          # "node.name" = "Dummy-Driver";
          # "priority.driver" = 8000;
        # };
      # }
      # {
        # factory = "adapter";
        # args = {
          # "factory.name" = "support.null-audio-sink";
          # "node.name" = "Microphone-Proxy";
          # "node.description" = "Microphone";
          # "media.class" = "Audio/Source/Virtual";
          # "audio.position" = "MONO";
        # };
      # }
      # {
        # factory = "adapter";
        # args = {
          # "factory.name" = "support.null-audio-sink";
          # "node.name" = "Main-Output-Proxy";
          # "node.description" = "Main Output";
          # "media.class" = "Audio/Sink";
          # "audio.position" = "FL,FR";
        # };
      # }
    # ];
  # };

  # services.pipewire.extraConfig.pipewire-pulse."92-low-latency" = {
    # "context.properties" = [
      # {
        # name = "libpipewire-module-protocol-pulse";
        # args = { };
      # }
    # ];
    # "pulse.properties" = {
      # "pulse.min.req" = "32/48000";
      # "pulse.default.req" = "32/48000";
      # "pulse.max.req" = "32/48000";
      # "pulse.min.quantum" = "32/48000";
      # "pulse.max.quantum" = "32/48000";
    # };
    # "stream.properties" = {
      # "node.latency" = "32/48000";
      # "resample.quality" = 1;
    # };
  # };

  # services.pipewire.socketActivation = false; 
  # Start WirePlumber (with PipeWire) at boot.
  # systemd.user.services.wireplumber.wantedBy = [ "default.target" ];
#+end_src

**** Enable touchpad support (enabled default in most desktopManager).
#+begin_src nix :tangle ./configuration.nix
  services.xserver.libinput.enable = true;
#+end_src

**** Define a user account. Don't forget to set a password with ‘passwd’.
#+begin_src nix :tangle ./configuration.nix
  users.users.asd = {
    isNormalUser = true;
    shell = unstable.fish;
    description = "asd";
    extraGroups = ["networkmanager" "wheel" "audio" "incus-admin" "libvirtd"];
    packages = with pkgs; [
      kdePackages.kate
      # thunderbird
    ];
  };
#+end_src

***** COMMENT keep user services running
#+begin_src nix :tangle ./configuration.nix
  users.users.asd.linger = true; 
#+end_src

**** zsh

***** Set default shell to zsh
#+begin_src nix :tangle ./configuration.nix
  users.defaultUserShell = pkgs.zsh;
#+end_src

***** BEGIN
#+begin_src nix :tangle ./configuration.nix
  programs.zsh = {
#+end_src

***** MAIN

****** ENABLE
#+begin_src nix :tangle ./configuration.nix
  enable = true;
#+end_src

****** COMMENT With Zplug:
#+begin_src nix :tangle ./configuration.nix
  zplug = {
    enable = true;
    plugins = [
      {name = "zsh-users/zsh-autosuggestions";} # Simple plugin installation
      {
        name = "romkatv/powerlevel10k";
        tags = [ "as:theme" "depth:1" ];
      } # Installations with additional options. For the list of options, please refer to Zplug README.
    ];
  };
#+end_src

****** With Oh-My-Zsh:
#+begin_src nix :tangle ./configuration.nix
  oh-my-zsh = {
    enable = true;
    plugins = ["git" "starship" "zoxide"];
    theme = "robbyrussell";
  };
#+end_src

****** COMMENT With Antidote:
#+begin_src nix :tangle ./configuration.nix
  antidote = {
    enable = true;
    plugins = [''
      zsh-users/zsh-autosuggestions
      ohmyzsh/ohmyzsh path:lib/git.zsh
    '']; # explanation of "path:..." and other options explained in Antidote README.
#+end_src

****** COMMENT Manual
#+begin_src nix :tangle ./configuration.nix
    plugins = [
      {
        name = "zsh-autocomplete";
        src = pkgs.fetchFromGitHub {
          owner = "marlonrichert";
          repo = "zsh-autocomplete";
          rev = "23.07.13";
          sha256 = "sha256-/6V6IHwB5p0GT1u5SAiUa20LjFDSrMo731jFBq/bnpw=";
        };
      }
      {
        name = "powerlevel10k";
        src = pkgs.zsh-powerlevel10k;
        file = "share/zsh-powerlevel10k/powerlevel10k.zsh-theme";
      }
      {
        name = "powerlevel10k-config";
        src = ./p10k-config;
        file = "p10k.zsh";
      }
      {
        name = "zsh-syntax-highlighting";
        src = pkgs.fetchFromGitHub {
          owner = "zsh-users";
          repo = "zsh-syntax-highlighting";
          rev = "0.8.0";
          sha256 = "sha256-iJdWopZwHpSyYl5/FQXEW7gl/SrKaYDEtTH9cGP7iPo=";
        };
      }
    ];
#+end_src

***** END
#+begin_src nix :tangle ./configuration.nix
  };
#+end_src

**** Fish
#+begin_src nix :tangle ./configuration.nix
  programs.fish = {
      enable = true;
      package = unstable.fish;
  } ;
#+end_src

***** COMMENT Set default shell to fish
#+begin_src nix :tangle ./configuration.nix
  users.defaultUserShell = unstable.fish;
#+end_src

**** firefox.
#+begin_src nix :tangle ./configuration.nix
  programs.firefox.enable = true;
#+end_src

**** Allow unfree packages
#+begin_src nix :tangle ./configuration.nix
  nixpkgs.config.allowUnfree = true;
#+end_src


**** ENABLE virt-manager
#+begin_src nix :tangle ./configuration.nix
  programs.virt-manager.enable = true;
#+end_src

**** Containers and virtualizating

***** BEGIB
#+begin_src nix :tangle ./configuration.nix
  virtualisation = {
#+end_src

***** MAIN

****** ENABLE VIRT-MANAGER
#+begin_src nix :tangle ./configuration.nix
libvirtd.enable = true;
#+end_src


****** ENABLE CONTAINERS
#+begin_src nix :tangle ./configuration.nix
  containers.enable = true;
#+end_src

****** INCUS
#+begin_src nix :tangle ./configuration.nix
  incus.enable = true;
#+end_src

****** PODMAN
#+begin_src nix :tangle ./configuration.nix
  podman = {
      enable = true;

      # Create a `docker` alias for podman, to use it as a drop-in replacement
      dockerCompat = true;

      # Required for containers under podman-compose to be able to talk to each other.
      defaultNetwork.settings.dns_enabled = true;
  };
#+end_src

***** ED
#+begin_src nix :tangle ./configuration.nix
  };
#+end_src

**** List packages installed in system profile

***** To search, run:

#+begin_src sh :shebang #!/bin/sh :results output
  nix search wget
#+end_src

***** full list

****** BEGIN
#+begin_src nix :tangle ./configuration.nix
  environment.systemPackages = with pkgs; [
#+end_src

****** FULL LIST

******* COMMENT DISABLED
#+begin_src nix :tangle ./configuration.nix
  fishPlugins.done
  fishPlugins.forgit
  fishPlugins.fzf-fish
  fishPlugins.grc
  fishPlugins.hydro
  helix
#+end_src

******* MAIN PACKAGES
#+begin_src nix :tangle ./configuration.nix
  acpi
  alacritty
  alejandra
  alsa-utils
  appstream
  aria2
  atuin
  bat
  bottom
  brave
  brightnessctl
  byobu
  cargo
  catppuccin-kde
  clang-tools_19
  clinfo
  cmake
  curl
  debootstrap
  difftastic
  dig
  distrobox
  dive # look into docker image layers
  dmidecode
  dnsmasq
  docker-compose # start group of containers for dev
  dust
  emacs30
  fd
  file
  foot
  fuse3
  fzf
  gcc
  gcc14Stdenv
  gdk-pixbuf
  gdm
  git
  glib
  gpgme
  grc
  grim
  grub2
  grub2_efi
  gsettings-desktop-schemas
  ironbar
  jq
  json-glib
  kitty
  libarchive
  libcap
  libgcc
  librsvg
  libseccomp
  libxml2
  lsd
  lxc
  mako
  man-pages
  man-pages-posix
  meson
  miniserve
  mpv
  neovim
  networkmanagerapplet
  networkmanager-openconnect
  nh
  nix-index
  nix-ld
  nm-tray
  nushell
  openconnect
  openssl
  parted
  pavucontrol
  pciutils
  pkg-config
  podman
  podman-compose # start group of containers for dev
  podman-tui # status of containers in the terminal
  python3
  python3Full
  qbittorrent-enhanced
  rclone
  ripgrep
  ruff
  rustc
  shellcheck
  skim
  squashfsTools
  starship
  swayosd
  texliveFull
  tmux
  tree
  unzip
  uv
  vim
  vscode-fhs
  waybar
  wayland
  wayland-protocols
  wf-recorder
  wget
  wlogout
  wlsunset
  wofi
  yazi
  zip
  zoxide
  zstd
#+end_src

******* ROCM stuff

******** Enabled
#+begin_src nix :tangle ./configuration.nix
  rocmPackages.hipblas
  rocmPackages.hipcc
#+end_src

******** COMMENT Disabled
#+begin_src nix :tangle ./configuration.nix
  rocmPackages.meta.rocm-all
  rocmPackages.half
  rocmPackages.hipblas
  rocmPackages.hipcc
  rocmPackages.meta
  rocmPackages.rocfft
  rocmPackages.rocrand
#+end_src

******* UNSTABLE PACKAGES
#+begin_src nix :tangle ./configuration.nix
  unstable.nixfmt-rfc-style
  unstable.wezterm
  unstable.helix
#+end_src

******* CUSTOM SOURCES
#+begin_src nix :tangle ./configuration.nix
  (callPackage /root/debMirror.nix {})
#+end_src

******* Wrapper scripts

******** M_C_ESC
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_ESC" ''

  #include <unistd.h>

  static char * const args[] = {"wlogout", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** M_F1
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_F1" ''

  #include <unistd.h>

  static char * const args[] = {"footclient", "-e", "byobu-tmux", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** M_F2
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_F2" ''

  #include <unistd.h>

  static char * const args[] = {"footclient", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** M_F3
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_F3" ''

  #include <unistd.h>

  static char * const args[] = {"emacsclient", "-c", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Numerical programs parts

********* M_C_1
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_1" ''

  #include <unistd.h>
  #include <sys/wait.h>

  int start (char * const * argv) {
      int ret = execvp(argv[0], argv);
      return ret;
  }

  int do_start (char * const * argv) {
      pid_t p_start;
      int ret_start;
      p_start = fork();
      if(p_start == 0){
          ret_start = start (argv);
          return ret_start;
      }
      waitpid(p_start, NULL, 0);
      return 0;
  }

  static char * const args[] = {"emacs", NULL};

  int main () {
      do_start(args);
      return 0;
  }

  '')
#+end_src

********* M_C_2
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_2" ''

  #include <unistd.h>

  static char * const args[] = {"emacsclient", "-c", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** TY
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "TY" ''

  #include <unistd.h>
  #include <sys/wait.h>

  int start (char * const * argv) {
      int ret = execvp(argv[0], argv);
      return ret;
  }

  int do_start (char * const * argv) {
      pid_t p_start;
      int ret_start;
      p_start = fork();
      if(p_start == 0){
          ret_start = start (argv);
          return ret_start;
      }
      waitpid(p_start, NULL, 0);
      return 0;
  }

  static char * const args[] = {"byobu-tmux", NULL};

  int main () {
      do_start(args);
      return 0;
  }

  '')
#+end_src

******** enter emacs flatpak

flatpak run --command=bash org.gnu.emacs

#+begin_src nix :tangle ./configuration.nix
  (writeCBin "enter_emacs_flatpak" ''

  #include <unistd.h>

  static char * const args[] = {"flatpak", "run", "--command=bash", "org.gnu.emacs", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Terminal parts

********* M_C_Q
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_Q" ''

  #include <unistd.h>

  static char * const args[] = {"wezterm", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_C_W
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_W" ''

  #include <unistd.h>

  static char * const args[] = {"alacritty" , "msg" , "create-window" , "-e" , "byobu-tmux" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_C_E
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_E" ''

  #include <unistd.h>

  static char * const args[] = {"alacritty" , "msg" , "create-window" , "-e" , "enter_emacs_flatpak" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_C_R
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_R" ''

  #include <unistd.h>

  static char * const args[] = {"footclient" , "-e" , "enter_emacs_flatpak" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_C_T

********** COMMENT New
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_T" ''

  #include <unistd.h>
  #include <sys/wait.h>

  int start (char * const * argv) {
      int ret = execvp(argv[0], argv);
      return ret;
  }

  int do_start (char * const * argv) {
      pid_t p_start;
      int ret_start;
      p_start = fork();
      if(p_start == 0){
          ret_start = start (argv);
          return ret_start;
      }
      waitpid(p_start, NULL, 0);
      return 0;
  }

  int alacritty_server () {
      static char * const alacritty[] = {"alacritty" , "-e" , "foot" , "-s" , NULL};
      do_start(alacritty);
  }

  int main () {
      alacritty_server();
  }

  '')
#+end_src

********** old
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_T" ''

  #include <unistd.h>
  #include <sys/wait.h>

  int foot_server () {
      static char * const args[] = {"foot" , "-s" , NULL};
      int ret = execvp(args[0], args);
      return ret;
  }

  int alacritty_server () {
      static char * const args[] = {"alacritty" , "-e" , "TY" , NULL};
      int ret = execvp(args[0], args);
      return ret;
  }

  int both () {
      pid_t p_foot;
      pid_t p_alacritty;
      int ret_foot;
      int ret_alacritty;

      p_foot = fork();
      if(p_foot == 0){
          ret_foot = foot_server ();
          return ret_foot;
      }

      p_alacritty = fork();
      if(p_alacritty == 0){
          ret_alacritty = alacritty_server ();
          return ret_alacritty;
      }

      waitpid(p_foot, NULL, 0);
      waitpid(p_alacritty, NULL, 0);

      return 0;
  }

  int main () {
      both();
      return 0;
  }

  '')
#+end_src

******** Browser and remote parts

********* M_C_A
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_A" ''

  #include <unistd.h>

  static char * const args[] = {"firefox" ,  NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_C_S
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_S" ''

  #include <unistd.h>

  static char * const args[] = {"brave" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** File browser
********* M_C_D
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_D" ''

  #include <unistd.h>

  static char * const args[] = {"dolphin" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Audio volume

********* M_C_F
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_F" ''

  #include <unistd.h>

  static char * const args[] = {"pavucontrol" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Network

********* M_C_G
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_C_G" ''

  #include <unistd.h>

  static char * const args[] = {"footclient", "nmtui" , NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Sound volume

********* M_A_Q
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_Q" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "0%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_W
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_W" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "11%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_E
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_E" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "22%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_R
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_R" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "33%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_T
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_T" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "44%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_Y
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_Y" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "55%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_U
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_U" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "66%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_I
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_I" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "77%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_O
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_O" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "88%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_P
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_P" ''

  #include <unistd.h>

  static char * const args[] = {"amixer", "set", "Master,0", "100%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** Screen brightness

********* M_A_GRAVE
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_GRAVE" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "0%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_1
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_1" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "10%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_2
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_2" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "20%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_3
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_3" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "30%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_4
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_4" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "40%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_5
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_5" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "50%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_6
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_6" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "60%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_7
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_7" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "70%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_8
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_8" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "80%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_9
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_9" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "90%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

********* M_A_0
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "M_A_0" ''

  #include <unistd.h>

  static char * const args[] = {"brightnessctl", "set", "100%", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

******** COMMENT Replace kwin with wayfire
#+begin_src nix :tangle ./configuration.nix
  (writeCBin "kwin_wayland" ''

  #include <unistd.h>

  static char * const args[] = {"wayfire", NULL};

  int main () {
      int ret = execvp(args[0], args);
      return ret;
  }

  '')
#+end_src

****** END
#+begin_src nix :tangle ./configuration.nix
  ];
#+end_src

**** Get details about manufacturer
#+begin_src sh :shebang #!/bin/sh :results output
  dmidecode -t system
#+end_src

**** COMMENT SUID wrappers
Some programs need SUID wrappers, can be configured further or are
started in user sessions.

***** MTR
#+begin_src nix :tangle ./configuration.nix
  programs.mtr.enable = true;
#+end_src

***** GPG
#+begin_src nix :tangle ./configuration.nix
  programs.gnupg.agent = {
      enable = true;
      enableSSHSupport = true;
  };
#+end_src

**** List services that you want to enable:

***** Enable the OpenSSH daemon.
#+begin_src nix :tangle ./configuration.nix
  services.openssh.enable = true;
#+end_src

***** Enable flatpak.
#+begin_src nix :tangle ./configuration.nix
  services.flatpak = {
      enable = true;
      package = unstable.flatpak;
  } ;
#+end_src

**** Configure DNSMASQ
#+begin_src nix :tangle ./configuration.nix
  services.dnsmasq = {
      enable = true;
      alwaysKeepRunning = true;
      resolveLocalQueries = true;
      settings = {
        server = [ "192.168.1.254" "4.2.2.2" "8.8.8.8" "8.8.8.4" "8.8.4.4" "76.76.2.0" "76.76.10.0" "9.9.9.9" "149.112.112.112" "208.67.222.222" "208.67.220.220" "1.1.1.1" "1.0.0.1" "94.140.14.14" "94.140.15.15" "185.228.168.9" "185.228.169.9" "76.76.19.19" "76.223.122.150" ] ;
        local-service = true; # Accept DNS queries only from hosts whose address is on a local subnet
        log-queries = true; # Log results of all DNS queries
        bogus-priv = true; # Don't forward requests for the local address ranges (192.168.x.x etc) to upstream nameservers
        domain-needed = true; # Don't forward requests without dots or domain parts to upstream nameservers
        all-servers = true;
        dnssec = true; # Enable DNSSEC
        # DNSSEC trust anchor. Source: https://data.iana.org/root-anchors/root-anchors.xml
        trust-anchor = ".,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D";
      };
    };
#+end_src


**** NixOS release (DONOT CHANGE THIS!!!)
This value determines the NixOS release from which the default
settings for stateful data, like file locations and database versions
on your system were taken. It‘s perfectly fine and recommended to leave
this value at the release version of the first install of this system.
Before changing this value read the documentation for this option
(e.g. man configuration.nix or on https://nixos.org/nixos/options.html).

***** Did you read the comment?
#+begin_src nix :tangle ./configuration.nix
  system.stateVersion = "24.11";
#+end_src

*** END
#+begin_src nix :tangle ./configuration.nix
  }
#+end_src

* Sample

** hardware-configuration
#+begin_src nix :tangle ./hardware-configuration.nix
#+end_src

** configuration
#+begin_src nix :tangle ./configuration.nix
#+end_src
